---
layout:     post
title:      "java8源码——List"
subtitle:   " \"Read The Fuking Source Code--List\""
date:       2018-09-12 12:00:00
author:     "Bz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - java后端
    - 数据结构
---
# List特性介绍
> “  List 是一个有序集合，用户可以用这个精确控制每个插入到这个集合的元素，通过整数索引找到并使用元素。”
  
> “与Set不同，List允许有重复的元素，更正式的说法是，List允许元素e1.equals(e2)==true,且如果List的实现类允许存在null元素的话，可以存在多个null元素，用户也可以禁止这种重复行为，在尝试插入重复元素时抛出运行时异常来阻止，但是这种做法比较少见。”

> “List提供了四种方式来定位并使用元素，索引从0开始，有些实现类的执行时间与索引值的大小成比例，因此，在不知道具体实现的时候，用迭代的方式比遍历更好。”
  
> “List接口提供了一种特殊的迭代——ListIterator，不仅允许Iterator接口提供的正常操作外，还允许元素插入和替换，还提供了一种方法来获取从指定位置开始的迭代器。”

> “List接口提供了两种方法来查找指定对象，从性能的角度看，这些方法应该谨慎使用，在很多实现中，他们的线性查找代价是昂贵的。”

> “List接口提供了两种方法在集合指定位置插入或替换多个元素”

> “List接口允许把自身作为元素插入其中，但要特别小心的是，这样的list上，equals和hashCide将可能发生变化。”

> “List接口的一些实现对其包含的元素有限制，例如一些实现禁止null元素，一些实现对它们元素的类型有限制，试图添加不合格元素将抛出NullPointerException或ClassCastException。尝试查询不合格的元素将抛出异常或只是简单的返回一个false。更通常的，尝试对不合格的元素进行操作的时候，可能抛出异常或成功插入，这取决于具体实现的选择，这类异常在规范中标记为可选”

## **==Node==**

    使用Map时需要特别注意的是，尽量保证key的值是不可变的。
    因为Map存储元素时候会计算key的哈希值，并根据这个哈希值把value插入到合适的位置，查找时再次计算key的哈希值到特定位置找到value。
    如果使用可变对象作为Map的key，在改变对象的值的时候，哈希值会发生改变，导致插入和查找计算出来的哈希值并不一样，造成数据丢失。
    如果一定要使用可变对象作为key，需要重写hashcode和equals方法，保证哈希值不变，另外value使用可变值是可行的。

- 所有Map的实现类遵守两个标准：拥有一个空构造器、拥有一个含有Map类型的参数，用于Map不同实现类之间的转换。

# List接口

接口方法|作用
-|-
int size()|返回List中元素的数量
boolean isEmpty()|验证List是否为空
oolean contains(Object o)|验证集合中至少包含一个参数元素
Iterator< E> iterator()|返回一个迭代器
Object[] toArray()|按顺序将List转换成数组
< T> T[] toArray(T[] a)|按顺序讲List转换成泛型数组，以null值填充数组多余的空位
boolean add(E e)|添加指定元素至列表末尾
boolean remove(Object o)|从列表移除指定元素
boolean containsAll(Collection<?> c)|验证参数列表是否被包含
boolean addAll(Collection<? extends E> c)|将参数列表中的元素按返回顺序添加至列表
boolean addAll(int index, Collection<? extends E> c)|将参数列表中的元素按迭代器返回顺序添加至列表指定位置
boolean removeAll(Collection<?> c)|将参数列表中含有的元素从列表中移除
boolean retainAll(Collection<?> c)|只保留参数列表中含有的元素
void clear()|清空列表
boolean equals(Object o)|参数列表中的元素与列表顺序、值相等
int hashCode()|返回列表的哈希值
E get(int index)|返回列表中指定位置的元素
E set(int index, E element)|用参数元素替换列表指定位置的元素
void add(int index, E element)|将参数元素插入到列表指定位置
E remove(int index)|移除列表指定位置的元素
int indexOf(Object o)|返回参数元素在列表中首次出现的index/不存在返回-1
int lastIndexOf(Object o)|返回参数元素在列表中最后出现的index/不存在返回-1
ListIterator< E> listIterator()|返回列表迭代器
ListIterator< E> listIterator(int index)|以参数index作为迭代器首个值返回
List< E> subList(int fromIndex, int toIndex)|截取子列表从参数fromIndex(包括)至toIndex(不包括)
default void replaceAll(UnaryOperator< E> operator)|将列表中的每个元素替换成参数元素
default void sort(Comparator<? super E> c)|对列表进行重新排序

其中 **==default==** 关键字是java8特性，修饰接口中的方法时，可以对其进行实现。

## List的四个实现类


- 1、ArrayList
非线程安全
基于对象数组
get(int index)不需要遍历数组，速度快；
iterator()方法中调用了get(int index)，所以速度也快
set(int index, E e)不需要遍历数组，速度快
add方法需要考虑扩容与数组复制问题，速度慢
remove(Object o)需要遍历数组，并复制数组元素，速度慢
remove(int index)不需要遍历数组，需要复制数组元素，但不常用
contain(E)需要遍历数组
- 2、LinkedList

非线程安全
基于环形双向链表
get(int index)需要遍历链表，速度慢；
iterator()方法中调用了get(int index)，所以速度也慢
set(int index, E e)方法中调用了get(int index)，所以速度也慢
add方法不需要考虑扩容与数组复制问题，只需创建新对象，再将新对象的前后节点的指针指向重新分配一下就好，速度快
remove(Object o)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，速度快
remove(int index)需要遍历链表，但不需要复制元素，只需将所要删除的对象的前后节点的指针指向重新分配一下以及将所要删除的对象的三个属性置空即可，但不常用
contain(E)需要遍历链表
- 3、Vector（线程安全的ArrayList）

线程安全
扩容机制与ArrayList不同
- 4、Stack（继承于Vector）

线程安全
效率低下，可采用双端队列Deque或LinkedList来实现，Deque用的较多


### ---1、ArrayList
属性|作用
-|-
private static final int DEFAULT_CAPACITY = 10;|初始化容器的大小
private static final Object[] EMPTY_ELEMENTDATA = {};|空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};|默认大小的空数组
transient Object[] elementData;|数组缓冲区
private int size|集合中元素数量

- ArrayList的初始容量是10，可以缩小容量：以元素数量作为容量

    public void ==trimToSize==()

    也可以扩增容量到指定大小:minCapacity

    public void ==ensureCapacity==(int minCapacity)
    
    若指定大小比 ++MAX_ARRAY_SIZE++ 还大,则用 ++Integer.MAX_VALUE++ 作为容器大小

    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    
-  contains(Object o)是通过 o.==equals==(elementData[i]) 来判断是否包含元素
-  add(E e)每次调用都需要扩大一次集合容量



-  removeRange(int fromIndex, int toIndex)提供了批量移除
### ---2、LinkedList
### ---3、Vector
### ---4、Stack