---
layout:     post
title:      "redis-3.持久化"
subtitle:   " \"keep hungry keep foolish\""
date:       2019-05-25 12:00:00
author:     "Bz"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - redis
    
#     redis-3.持久化
    
---
## redis持久化的机制


### 1.RDB和AOF两种持久化机制的介绍
    RDB持久化机制,对redis中的数据执行周期性的持久化
    AOF把每条写入命令记录成日志,以append-only的模式写入一个日志文件中,在redis重启的时候,可以通过回放AOF日志中的写指令来重新构建整个数据集
### 2.RDB持久化机制的优点
	1.RDB会生成多个数据文件,每个数据文件都代表了某一时刻中redis的数据,这种多个数据文件的方式,非常适合做冷备、定时备份到云服务器上
		RDB做冷备:生成多个文件,每个文件都代表了某一个时刻的完整的数据快照
		AOF做冷备:只有一个文件,但可以每隔一定时间,copy一份这个文件
	2.RDB对redis对外提供的读写服务,影响非常小,可以让redis保持高性能,因为redis主进程只需要fork一个子进程,
    	让子进程执行磁盘IO操作来进行RDB持久化即可
		RDB:每次写都是直接在redis内存中,只在一定时间,才会把数据写入到磁盘
		AOF:每次都要写文件,虽然使用了os cache,但还是有一定的时间开销,速度比RDB略慢
	3.相对AOF持久化机制来说,直接基于RDB数据文件来重启和恢复redis进程速度更快
		RDB:就是一份完整的数据文件,恢复的时候直接加载到内存即可
		AOF:存放的指令日志,做数据恢复的时候,需要回放和执行所有的指令,从而来恢复数据
### 3.RDB持久化机制的缺点
	1.如果想要在redis故障恢复时,尽可能少的丢失数据,RDB没有AOF好,因为RDB生成快照文件有时间间隔,在这个间隔期间宕机,会丢失这段时间的数据
	2.RDB每次fork子进程来执行RDB快照文件数据生成的时候,如果数据文件特别大,会影响到对客户端提供的服务暂停数毫秒,甚至数秒
### 4.AOF持久化的优点
	1.AOF可以更好的保护数据不丢失,一般AOF每个1秒,执行一次fsync操作(将os cache中的数据写入磁盘),即使redis宕机,最多只丢失1秒的数据
	2.AOF日志文件以append-only模式写入,所以不用磁盘寻址,写入性能高,且文件不易破损,即使文件尾部破损也很容易恢复
	3.AOF日志文件即使过大,后台执行重写操作,也不会影响到客户端的读写操作,因为rewrite log时,会进行压缩,创建出一份需要恢复数据的最小日志出来,
	    再创建新日志的时候,旧日志还是照常写入,当新的merge后的日志ready的时候,再交换新旧日志文件即可
	4.AOF日志文件的命令通过非常可读的方式进行记录,这个特性非常适合做灾难性的误删除的紧急恢复,比如数据不小心被错误清除了,
	    只要这个后台rewrite还没发生,那么就可以立即拷贝AOF文件,将最后一条flushall命令删除,
	    然后再将AOF文件放回去,就可以通过恢复机制,自动恢复所有数据
### 5.AOF持久化机制的缺点
	1.对同一份数据来说,AOF日志文件通常比RDB数据快照文件更大
	2.AOF开启后,支持的写qps会比rbd低,因为AOF一般会配置成每秒fsync一次日志文件,
	    如果要保证数据一条都不丢失,可以将AOF的fsync设置成每写入一条数据,fsync一次,但qps会大大降低
	3.AOF进行数据恢复的时候可能会出现bug,相比RDB恢复一份完整的数据快照,AOF的恢复方式相对脆弱一些
	4.唯一比较大的缺点是做数据恢复的时候会比较慢,做冷备的时候不方便,需要自己写复杂的脚本




	
## 总结:

    1.不要仅使用RDB,因为可能会导致比较多的数据丢失
    2.也不要仅使用AOF,因为数据恢复慢,且恢复数据时容易出现bug
    3.综合使用AOF和RDB两种持久化机制,用AOF来保证数据不丢、少丢,用RDB做冷备,即使AOF文件丢失或者损坏不可用,还可以使用RDB来快速恢复数据


